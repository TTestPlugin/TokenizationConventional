#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
#ifndef TPCSDKSWIFT_SWIFT_H
#define TPCSDKSWIFT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="TPCSDKSwift",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
@class NSString;

/// Asset data returned by <code>TPCSDK.getCardAsset(...)</code>
SWIFT_CLASS("_TtC11TPCSDKSwift9CardAsset")
@interface CardAsset : NSObject
/// Type of asset
@property (nonatomic, copy) NSString * _Nullable type;
/// Base64 encoded data
@property (nonatomic, copy) NSString * _Nullable data;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

///  Card Asset Image size
typedef SWIFT_ENUM(NSInteger, CardAssetSize, open) {
/// Small
  CardAssetSizeS = 0,
/// Medium
  CardAssetSizeM = 1,
/// Large
  CardAssetSizeL = 2,
};

@class PKPass;

/// Card digitization result details
/// seealso:
/// <code>TPCSDK.getCardDigitizationResult(card:primaryAccountIdentifier:)</code>
SWIFT_CLASS("_TtC11TPCSDKSwift22CardDigitizationResult")
@interface CardDigitizationResult : NSObject
/// PKPass for the card on the local device, nil if not digitized on local device
@property (nonatomic, strong) PKPass * _Nullable localPKPass;
/// PKPass for the card on remote device, nil if not digitized on remote device
@property (nonatomic, strong) PKPass * _Nullable remotePKPass;
/// Constructor for CardDigitizationResult
/// \param localPKPass PKPass for the card on the local device, nil if not digitized on local device
///
/// \param remotePKPass PKPass for the card on remote device, nil if not digitized on remote device
///
- (nonnull instancetype)initWithLocalPKPass:(PKPass * _Nullable)localPKPass remotePKPass:(PKPass * _Nullable)remotePKPass OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Card list returned by <code>TPCSDK.getCardList(...)</code>
SWIFT_CLASS("_TtC11TPCSDKSwift8CardList")
@interface CardList : NSObject
/// Card ID
@property (nonatomic, copy) NSString * _Nullable id;
/// Card state
@property (nonatomic, copy) NSString * _Nullable state;
/// Card expiry date
@property (nonatomic, copy) NSString * _Nullable expiryDate;
/// Card type
@property (nonatomic, copy) NSString * _Nullable type;
/// Enumeration of the primary card scheme such as VISA, MASTERCARD, PAGOBANCOMAT
@property (nonatomic, copy) NSString * _Nullable primaryScheme;
/// Card auxiliary scheme
@property (nonatomic, copy) NSString * _Nullable auxiliaryScheme;
/// Card user account
@property (nonatomic, copy) NSString * _Nullable userAccount;
/// Bank code such as BLZ, BIC
@property (nonatomic, copy) NSString * _Nullable bankCode;
/// Card prefix
@property (nonatomic, copy) NSString * _Nullable prefix;
/// Card number suffix
@property (nonatomic, copy) NSString * _Nullable suffix;
/// PAN sequence number
@property (nonatomic, copy) NSString * _Nullable psn;
/// Card holder name
@property (nonatomic, copy) NSString * _Nullable cardholderName;
/// Card registration code
@property (nonatomic, copy) NSString * _Nullable registrationCode;
/// Terms and conditions URL
@property (nonatomic, copy) NSString * _Nullable tncUrl;
/// Card image url, if it’s not provided the card image can be retrieved using getCardArt API
@property (nonatomic, copy) NSString * _Nullable imageUrl;
/// List of tokenUniqueReferences linked to the card. It’s only provided if the card has been digitized into devices
@property (nonatomic, copy) NSArray<NSString *> * _Nullable tokenUniqueReferences;
/// List of panUniqueReferences linked to the card. It’s only provided if the card has been digitized into devices
@property (nonatomic, copy) NSArray<NSString *> * _Nullable panUniqueReferences;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Card payment network
typedef SWIFT_ENUM(NSInteger, CardScheme, open) {
/// Mastercard
  CardSchemeMastercard = 0,
/// Visa
  CardSchemeVisa = 1,
/// PagoBancomat
  CardSchemePagoBancomat = 2,
/// Amex
  CardSchemeAmex = 3,
/// DISCOVER
  CardSchemeDiscover = 4,
};


/// User details required for Mastercard Click to Pay push provisioning
/// since:
/// 2.4.0
SWIFT_CLASS("_TtC11TPCSDKSwift20Click2PayUserDetails")
@interface Click2PayUserDetails : NSObject
/// Consumer-provided first name. Maximum character length must be 30.
@property (nonatomic, readonly, copy) NSString * _Nonnull firstName;
/// Consumer-provided last name. Maximum character length must be 30.
@property (nonatomic, readonly, copy) NSString * _Nonnull lastName;
/// Consumer preferred locale (language and country). This information will be useful to the Token Requestor to offer the best consumer experience during digitization.
/// Format: Two letter ISO 639-1 language in lowercase, with a underscore (”_”), followed by two letter ISO 3166-1 country code in uppercase. Example : en_US
@property (nonatomic, readonly, copy) NSString * _Nonnull locale;
/// Phone number country code. International calling code format UIT-T E.164. Numbers only. Without the plus sign. Example : 65
@property (nonatomic, readonly, copy) NSString * _Nonnull phoneNumberCountryCode;
/// Phone number without country code. National Destination Code or Number Planning Area + Subscriber Number. Example : 99998888
@property (nonatomic, readonly, copy) NSString * _Nonnull phoneNumber;
/// Consumer email in RFC 5322. Example : myemail@mail.com
@property (nonatomic, readonly, copy) NSString * _Nonnull email;
/// Constructor for Click2PayUserDetails
/// \param firstName Consumer-provided first name. Maximum character length must be 30.
///
/// \param lastName Consumer-provided last name. Maximum character length must be 30.
///
/// \param locale Consumer preferred locale (language and country). This information will be useful to the Token Requestor to offer the best consumer experience during digitization.
/// Format: Two letter ISO 639-1 language in lowercase, with a underscore (”_”), followed by two letter ISO 3166-1 country code in uppercase. Example : en_US
///
/// \param phoneNumberCountryCode Phone number country code. International calling code format UIT-T E.164. Numbers only. Without the plus sign. Example : 65
///
/// \param phoneNumber Phone number without country code. National Destination Code or Number Planning Area + Subscriber Number. Example : 99998888
///
/// \param email Consumer email in RFC 5322. Example : myemail@mail.com
///
- (nonnull instancetype)initWithFirstName:(NSString * _Nonnull)firstName lastName:(NSString * _Nonnull)lastName locale:(NSString * _Nonnull)locale phoneNumberCountryCode:(NSString * _Nonnull)phoneNumberCountryCode phoneNumber:(NSString * _Nonnull)phoneNumber email:(NSString * _Nonnull)email OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Device information
SWIFT_CLASS("_TtC11TPCSDKSwift6Device")
@interface Device : NSObject
/// Device ID
@property (nonatomic, copy) NSString * _Nullable id;
/// Device name
@property (nonatomic, copy) NSString * _Nullable name;
/// Device type
@property (nonatomic, copy) NSString * _Nullable type;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Bank application to initialize this object with <code>CardScheme</code> and encryptedPayload
/// note:
/// Initialize <code>FundingCard</code> with Mastercard and Encrypted Payload
/// \code
/// let scheme         = "MASTERCARD"
/// let cardPayload    = "PKCS7 encrypted PAN"
///
/// let card           = FundingCard(schemeString: scheme.
/// encryptedPayload: cardPayload)
///
/// \endcodenote:
/// Initialize <code>FundingCard</code> with Visa and Encrypted Payload
/// \code
/// let scheme         = "VISA"
/// let cardPayload    = "PKCS7 encrypted PAN"
///
/// let card           = FundingCard(schemeString: scheme.
/// encryptedPayload: cardPayload)
///
/// \endcodenote:
/// Initialize <code>FundingCard</code> with PagoBancomat and Encrypted Payload
/// \code
/// let scheme         = "PAGOBANCOMAT"
/// let cardPayload    = "PKCS7 encrypted PAN"
///
/// let card           = FundingCard(schemeString: scheme.
/// encryptedPayload: cardPayload)
///
/// \endcodenote:
/// Initialize <code>FundingCard</code> with Primary Account Identifier
/// \code
/// let cardIdentifier = "C-12345678"
///
/// let card           = FundingCard(primaryAccountIdentifier: cardIdentifier)
///
/// \endcode
SWIFT_CLASS("_TtC11TPCSDKSwift11FundingCard")
@interface FundingCard : NSObject
/// Card payment network
/// seealso:
/// <code>CardScheme</code>
@property (nonatomic, copy) NSString * _Nullable scheme;
/// Card information encrypted in PKCS7 using TIG TSH Certificate
@property (nonatomic, copy) NSString * _Nullable encryptedPayload;
/// Primary Account Identifier of the payment card
@property (nonatomic, copy) NSString * _Nullable primaryAccountIdentifier;
/// Initialize <code>FundingCard</code>
/// note:
/// Initialize <code>FundingCard</code> with Card’s scheme and Encrypted Payload
/// \code
/// let card = FundingCard(schemeString, cardPayload)
///
/// \endcodenote:
/// Initialize <code>FundingCard</code> with Primary Account Identifier
/// \code
/// let card = FundingCard(cardIdentifier)
///
/// \endcode\param scheme Card scheme. Could be <code>VISA</code>, <code>MASTERCARD</code>, <code>PAGOBANCOMAT</code> or others.
///
/// \param encryptedPayload Card information encrypted in PKCS7
///
/// \param primaryAccountIdentifier Primary Account Identifier of the payment card
///
- (nonnull instancetype)initWithSchemeString:(NSString * _Nullable)schemeString encryptedPayload:(NSString * _Nullable)encryptedPayload primaryAccountIdentifier:(NSString * _Nullable)primaryAccountIdentifier OBJC_DESIGNATED_INITIALIZER;
/// Constructor for FundingCard using Scheme and Encrypted Payload, or using Primary Account Identifier
/// note:
/// Initialize <code>FundingCard</code> with <code>CardScheme</code> and Encrypted Payload
/// \code
/// let card = FundingCard(scheme, cardPayload)
///
/// \endcode\param scheme <code>CardScheme</code>
///
/// \param encryptedPayload Card information encrypted in PKCS7
///
- (nonnull instancetype)initWithScheme:(enum CardScheme)scheme encryptedPayload:(NSString * _Nullable)encryptedPayload OBJC_DESIGNATED_INITIALIZER;
/// Constructor for FundingCard using Scheme and Encrypted Payload, or using Primary Account Identifier
/// note:
/// Initialize <code>FundingCard</code> with Primary Account Identifier
/// \code
/// let card = FundingCard(cardIdentifier)
///
/// \endcode\param primaryAccountIdentifier Primary Account Identifier of the payment card
///
- (nonnull instancetype)initWithPrimaryAccountIdentifier:(NSString * _Nullable)primaryAccountIdentifier OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSData;

/// Class containing inputs required for generating <code>PKAddPaymentPassRequest</code>.
/// since:
/// 2.3.0
SWIFT_CLASS("_TtC11TPCSDKSwift34GenerateAddPaymentPassRequestInput")
@interface GenerateAddPaymentPassRequestInput : NSObject
/// Card payment network
/// seealso:
/// <code>CardScheme</code>
@property (nonatomic, readonly) enum CardScheme scheme;
/// Card information encrypted in PKCS7.
@property (nonatomic, readonly, copy) NSString * _Nonnull encryptedPayload;
/// Authorization code provided by issuer.
@property (nonatomic, readonly, copy) NSString * _Nonnull authorizationCode;
/// Corresponds to certificateChain from <a href="https://developer.apple.com/documentation/passkit/pkissuerprovisioningextensionhandler/3571365-generateaddpaymentpassrequestfor">Apple generateAddPaymentPassRequest</a>.
@property (nonatomic, readonly, copy) NSArray<NSData *> * _Nonnull certificateChain;
/// Corresponds to nonce from <a href="https://developer.apple.com/documentation/passkit/pkissuerprovisioningextensionhandler/3571365-generateaddpaymentpassrequestfor">Apple generateAddPaymentPassRequest</a>.
@property (nonatomic, readonly, copy) NSData * _Nonnull nonce;
/// Corresponds to nonceSignature from <a href="https://developer.apple.com/documentation/passkit/pkissuerprovisioningextensionhandler/3571365-generateaddpaymentpassrequestfor">Apple generateAddPaymentPassRequest</a>.
@property (nonatomic, readonly, copy) NSData * _Nonnull nonceSignature;
/// Unique identifier of the card product. This data can be retrieved from Bank’s Card Management System. It is only applicable for domestic schemes. Maximum length is 32 characters.
@property (nonatomic, copy) NSString * _Nullable productId;
/// Initialize <code>GenerateAddPaymentPassRequestInput</code>.
/// \param scheme card scheme.
///
/// \param encryptedPayload Card information encrypted in PKCS7.
///
/// \param authorizationCode Authorization code provided by issuer.
///
/// \param certificateChain certificate chain provided by Apple.
///
/// \param nonce nonce provided by Apple.
///
/// \param nonceSignature nonce signature provided by Apple.
///
- (nonnull instancetype)initWithScheme:(enum CardScheme)scheme encryptedPayload:(NSString * _Nonnull)encryptedPayload authorizationCode:(NSString * _Nonnull)authorizationCode certificateChain:(NSArray<NSData *> * _Nonnull)certificateChain nonce:(NSData * _Nonnull)nonce nonceSignature:(NSData * _Nonnull)nonceSignature OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Bank application to initialize this object with last4 digits of PAN or serial number provided by Apple Pay.
/// \code
/// // Initialize object with last4 digits of PAN.
/// let last4          = "Last 4 Digits of PAN"
/// let tokenInput     = GetTokenInput(last4: last4)
///
/// // Initialize object with serial number provided by Apple Pay.
/// let serialNumber   = "Serial number provided by Apple Pay"
/// let tokenInput     = GetTokenInput(serialNumber: serialNumber)
///
/// \endcodesince:
/// 2.1.0
SWIFT_CLASS("_TtC11TPCSDKSwift13GetTokenInput")
@interface GetTokenInput : NSObject
/// Last 4 digits of PAN
/// Note: Last 4 digits of PAN setter is deprecated since V2.3.0.
@property (nonatomic, readonly, copy) NSString * _Nullable last4;
/// Serial number provided by Apple Pay.
/// since:
/// 2.3.0
@property (nonatomic, readonly, copy) NSString * _Nullable serialNumber;
/// Initialize <code>GetTokenInput</code> with last4 digits of PAN.
/// \code
/// let tokenInput = GetTokenInput(last4: last4)
///
/// \endcode\param last4 Last 4 digits of PAN
///
- (nonnull instancetype)initWithLast4:(NSString * _Nonnull)last4 OBJC_DESIGNATED_INITIALIZER;
/// Initialize <code>GetTokenInput</code> with serial number.
/// \code
/// let tokenInput = GetTokenInput(serialNumber: serialNumber)
///
/// \endcodesince:
/// 2.3.0
/// \param serialNumber Serial number
///
- (nonnull instancetype)initWithSerialNumber:(NSString * _Nonnull)serialNumber OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Card Digitization Result
typedef SWIFT_ENUM(NSInteger, IsCardDigitizedResult, open) {
/// The current device or an attached device both supports adding this payment card and does not already contain a payment card with the supplied encrypted payload or primary account identifier.
  IsCardDigitizedResultCardNotDigitized = 0,
/// The current device or an attached device both contain a payment card with the supplied encrypted payload or primary account identifier.
  IsCardDigitizedResultCardAlreadyDigitized = 1,
/// Error while retrieving card digitization result.
/// This Error could be return when one of the following condition is match:
/// <ol>
///   <li>
///     <code>issuerId</code> from config is null or empty
///   </li>
///   <li>
///     <code>primaryAccountIdentifier</code> parameter is null
///   </li>
///   <li>
///     <code>serverHostname</code> from config is null or empty
///   </li>
///   <li>
///     <code>card</code> parameter is null
///   </li>
///   <li>
///     <code>FundingCard.scheme</code> is null or empty
///   </li>
///   <li>
///     <code>FundingCard.encryptedPayload</code> is null or empty
///   </li>
///   <li>
///     Server error returns other than <code>116</code> error
///   </li>
/// </ol>
  IsCardDigitizedResultError = 2,
};




/// Pending activation payment pass from local and remote device
SWIFT_CLASS("_TtC11TPCSDKSwift21PendingActivationPass")
@interface PendingActivationPass : NSObject
/// PKPass for the card on local device, nil if not digitized on local device
@property (nonatomic, strong) PKPass * _Nullable localPKPass;
/// PKPass for the card on remote device, nil if not digitized on remote device
@property (nonatomic, strong) PKPass * _Nullable remotePKPass;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Push method
SWIFT_CLASS("_TtC11TPCSDKSwift10PushMethod")
@interface PushMethod : NSObject
/// Tolen requestor push handler
@property (nonatomic, copy) NSString * _Nullable pushHandler;
/// Platform type
@property (nonatomic, copy) NSString * _Nullable platformType;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// TPCSDK variant
typedef SWIFT_ENUM(NSInteger, SdkVariant, open) {
/// Pre-Production Environment
  SdkVariantPPROD = 0,
/// Production Environment
  SdkVariantPROD = 1,
};

@class UIViewController;
@protocol TPCSDKProvisionDelegate;
@class PKAddPaymentPassRequest;
@class PKPaymentPass;
@class Token;
@class TokenRequestorAsset;
enum TokenState : NSInteger;
@class TokenRequestor;

/// TPCSDK for iOS
SWIFT_CLASS("_TtC11TPCSDKSwift6TPCSDK")
@interface TPCSDK : NSObject
/// This is the version of the TPCSDK
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull tpcsdkVersion;)
+ (NSString * _Nonnull)tpcsdkVersion SWIFT_WARN_UNUSED_RESULT;
/// Reset SDK
+ (void)reset;
/// Configure SDK with <code>SdkVariant</code>  and Issuer ID.
/// note:
/// Using <code>SdkVariant</code> and Issuer ID
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.notSupported</code>
///   </li>
/// </ul>
/// \code
/// func application(_ application: UIApplication,
///    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
///     // Override point for customization after application launch.
///     
///     let tpcVariant = SdkVariant.PROD
///     let tpcIssuerId = "TPC_ISSUER"
///     try? TPCSDK.configure(variant: tpcVariant, issuerId: tpcIssuerId)
///     
///     return true
/// }
///
/// \endcode\code
/// - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
///     // Override point for [customization after application launch.
///     
///     SdkVariant tpcVariant = SdkVariantPROD;
///     NSString * tpcIssuerId = @"TPC_ISSUER";
///     NSError * error;
///     [TPCSDK configureWithVariant:tpcVariant issuerId:tpcIssuerId error:&error];
///
///     return YES;
/// }
///
/// \endcode\param variant Use SdkVariant.PPROD for Pre-Production server and SdkVariant.PROD for Production server.
///
/// \param issuerId Issuer ID is provided to you during onboarding process.
///
+ (BOOL)configureWithVariant:(enum SdkVariant)variant issuerId:(NSString * _Nonnull)issuerId error:(NSError * _Nullable * _Nullable)error;
/// Configure SDK with Server URL and Issuer ID.
/// note:
/// Using Server URL and Issuer ID
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.notSupported</code>
///   </li>
/// </ul>
/// \code
/// func application(_ application: UIApplication,
///    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
///     // Override point for customization after application launch.
///     
///     let tpcServerUrl = "https://hapi.dbp.thalescloud.io/mg/tpc"
///     let tpcIssuerId  = "TPC_ISSUER"
///     try? TPCSDK.configure(url: tpcServerUrl, issuerId: tpcIssuerId)
///     
///     return true
/// }
///
/// \endcode\code
/// - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
///     // Override point for [customization after application launch.
///     
///     NSString * tpcServerUrl = @"https://hapi.dbp.thalescloud.io/mg/tpc";
///     NSString * tpcIssuerId = @"TPC_ISSUER";
///     NSError * error;
///     [TPCSDK configureWithUrl:tpcServerUrl issuerId:tpcIssuerId error:&error];
///
///     return YES;
/// }
///
/// \endcode\param url Provide server URL without trailing slash (example: https://hapi.dbp.thalescloud.io).
///
/// \param issuerId Issuer ID is provided to you during onboarding process.
///
+ (BOOL)configureWithUrl:(NSString * _Nonnull)url issuerId:(NSString * _Nonnull)issuerId error:(NSError * _Nullable * _Nullable)error;
/// warning:
/// This API is deprecated as it does not provide information about pending activation and Apple Watch status. Please use getToken API instead.
/// Get card digitization status for local and remote device.
/// note:
/// Using <code>FundingCard</code> object initialized with Card’s Scheme and Encrypted Payload
/// note:
/// For AMEX and DISCOVER, it is mandatory to provide <code>scheme</code> and <code>primaryAccountNumberSuffix</code>.
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.getCardDigitizationResult(card: card) {
///    (primaryAccountIdentifier, digitizeDetails, error) in
/// }
///
/// \endcode\code
/// [TPCSDK getCardDigitizationResultWithCard:card
///                  primaryAccountIdentifier:NULL
///                                completion:^(NSString * _Nullable primaryAccountIdentifier,
///                                            CardDigitizationResult * _Nullable digitizeDetails,
///                                            NSError * _Nullable error) {
///
/// }];
///
/// \endcodenote:
/// Using <code>FundingCard</code> object initialized with Primary Account Identifier
/// \code
/// TPCSDK.getCardDigitizationResult(card: card) {
///    (primaryAccountIdentifier, digitizeDetails, error) in
/// }
///
/// \endcode\code
/// [TPCSDK getCardDigitizationResultWithCard:card
///                  primaryAccountIdentifier:NULL
///                                completion:^(NSString * _Nullable primaryAccountIdentifier,
///                                            CardDigitizationResult * _Nullable digitizeDetails,
///                                            NSError * _Nullable error) {
///
/// }];
///
/// \endcodenote:
/// Using Primary Account Identifier
/// \code
/// TPCSDK.getCardDigitizationResult(primaryAccountIdentifier: cardIdentifier) {
///    (primaryAccountIdentifier, digitizeDetails, error) in
/// }
///
/// \endcode\code
/// [TPCSDK getCardDigitizationResultWithCard:NULL
///                  primaryAccountIdentifier:cardIdentifier
///                                completion:^(NSString * _Nullable primaryAccountIdentifier,
///                                            CardDigitizationResult * _Nullable digitizeResult,
///                                            NSError * _Nullable error) {
/// }];
///
/// \endcode\param card <code>FundingCard</code> object initialized with Card’s Scheme and Encrypted Payload, or <code>FundingCard</code> object initialized with Primary Account Identifier
///
/// \param primaryAccountIdentifier Primary Account Identifier of the payment card
///
/// \param primaryAccountNumberSuffix The last four or five digits of the card’s number. This field is only used for AMEX/DISCOVER schemes.
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns digitizeDetails - See <code>CardDigitizationResult</code> and possible primaryAccountIdentifier. Otherwise, it returns error details.
///
+ (void)getCardDigitizationResultWithCard:(FundingCard * _Nullable)card primaryAccountIdentifier:(NSString * _Nullable)primaryAccountIdentifier primaryAccountNumberSuffix:(NSString * _Nullable)primaryAccountNumberSuffix completion:(void (^ _Nonnull)(NSString * _Nullable, CardDigitizationResult * _Nullable, NSError * _Nullable))completion SWIFT_DEPRECATED_MSG("This API is deprecated as it does not provide information about pending activation and Apple Watch status. Please use getToken API instead.");
/// Get token for local and remote device.
/// since:
/// 2.1.0
/// note:
/// Using <code>GetTokenInput</code> object initialized with last 4 digits of PAN or serial number provided by Apple Pay.
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.deviceEnvironmentUnsafe</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.getToken(input: tokenInput) {
///    (localPass, remotePass, error) in
/// }
///
/// \endcode\code
/// [TPCSDK getTokenWithInput:tokenInput
///                completion:^(PKPass *_Nullable localPass,
///                            PKPass *_Nullable remotePass,
///                            NSError *_Nullable error) {
/// }];
///
/// \endcode\param input See <code>GetTokenInput</code>
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns a local and remote <code>PKPass</code>. Otherwise, it returns error details.
///
+ (void)getTokenWithInput:(GetTokenInput * _Nonnull)input completion:(void (^ _Nonnull)(PKPass * _Nullable, PKPass * _Nullable, NSError * _Nullable))completion;
/// warning:
/// This API is deprecated as it does not provide information about pending activation and Apple Watch status. Please use getToken API instead.
/// Check card digitization status with <code>FundingCard</code> or Primary Account Identifier.
/// important:
/// Display Add to Apple Wallet button if digitizeResult is <code>IsCardDigitizedResult.CardNotDigitized</code>.
/// seealso:
/// <code>TPCSDK.getCardDigitizationResult(card:completion:)</code> for details of card digitization result on current device or an attached device.
/// note:
/// Using <code>FundingCard</code> object initialized with Card’s Scheme and Encrypted Payload
/// note:
/// For AMEX and DISCOVER, it is mandatory to provide <code>scheme</code> and <code>primaryAccountNumberSuffix</code>.
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.isCardDigitized(card: card) {
///     (primaryAccountIdentifier, digitizeResult, error) in
///         switch digitizeResult {
///            case .CardNotDigitized:
///                // TODO: Display Add to Apple Wallet button
///                break
///         default: break
///     }
/// }
///
/// \endcode\code
/// [TPCSDK isCardDigitizedWithCard:card
///        primaryAccountIdentifier:NULL
///                      completion:^(NSString * _Nullable primaryAccountIdentifier, enum IsCardDigitizedResult digitizeResult, NSError * _Nullable error) {
///     switch(digitizeResult) {
///         case IsCardDigitizedResultCardNotDigitized:
///            // TODO: Display Add to Apple Wallet button
///            break;
///         
///         default: break;
///     }
/// }];
///
/// \endcodenote:
/// Using <code>FundingCard</code> object initialized with Primary Account Identifier
/// \code
/// TPCSDK.isCardDigitized(card: card) {
///    (primaryAccountIdentifier, digitizeResult, error) in
///     
///         switch digitizeResult {
///             case .CardNotDigitized:
///             // TODO: Display Add to Apple Wallet button
///             break
///         default: break
///     }
/// }
///
/// \endcode\code
/// [TPCSDK isCardDigitizedWithCard:card
///        primaryAccountIdentifier:NULL
///                      completion:^(NSString * _Nullable primaryAccountIdentifier, enum IsCardDigitizedResult digitizeResult, NSError * _Nullable error) {
///     switch(digitizeResult) {
///         case IsCardDigitizedResultCardNotDigitized:
///            // TODO: Display Add to Apple Wallet button
///         break;
///         
///         default: break;
///     }
/// }];
///
/// \endcodenote:
/// Using Primary Account Identifier
/// \code
/// TPCSDK.isCardDigitized(primaryAccountIdentifier: cardIdentifier) {
///    (digitizeResult, error) in
///
///     switch digitizeResult {
///         case .CardNotDigitized:
///            // TODO: Display Add to Apple Wallet button
///         break
///
///         default:
///            // TODO: Hide Add to Apple Wallet button
///         break
///     }
/// }
///
/// \endcode\code
/// [TPCSDK isCardDigitizedWithCard:NULL
///        primaryAccountIdentifier:cardIdentifier
///                      completion:^(NSString * _Nullable primaryAccountIdentifier, enum IsCardDigitizedResult digitizeResult, NSError * _Nullable error) {
///     switch(digitizeResult) {
///         case IsCardDigitizedResultCardNotDigitized:
///         // TODO: Display Add to Apple Wallet button
///         break;
///         
///         default:
///         // TODO: Hide Add to Apple Wallet button
///         break;
///     }
/// }];
///
/// \endcode\param card <code>FundingCard</code> object initialized with Card’s Scheme and Encrypted Payload, or <code>FundingCard</code> object initialized with Primary Account Identifier
///
/// \param primaryAccountIdentifier Primary Account Identifier of the payment card
///
/// \param primaryAccountNumberSuffix The last four or five digits of the card’s number. This field is only used for AMEX/DISCOVER schemes.
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns digitizeResult - See <code>IsCardDigitizedResult</code> and possible primaryAccountIdentifier. Otherwise, it returns error details.
///
+ (void)isCardDigitizedWithCard:(FundingCard * _Nullable)card primaryAccountIdentifier:(NSString * _Nullable)primaryAccountIdentifier primaryAccountNumberSuffix:(NSString * _Nullable)primaryAccountNumberSuffix completion:(void (^ _Nonnull)(NSString * _Nullable, enum IsCardDigitizedResult, NSError * _Nullable))completion SWIFT_DEPRECATED_MSG("This API is deprecated as it does not provide information about pending activation and Apple Watch status. Please use getToken API instead.");
/// Displays an interface that lets users add cards to Apple Pay from within your app.
/// \code
/// TPCSDK.provision(fromController: self,
///            primaryAccountSuffix: "1234",
///                  cardholderName: "John Doe",
///                          scheme: CardScheme.Mastercard,
///                encryptedPayload: "PKCS7 encrypted PAN",
///               authorizationCode: "code",
///               provisionDelegate: self)
///
/// \endcode\code
/// [TPCSDK provisionFromController:self
///            primaryAccountSuffix:@"1234"
///                  cardholderName:@"John Doe"
///                          scheme:CardSchemeMastercard
///                encryptedPayload:@"PKCS7 encrypted PAN"
///               authorizationCode:@"code"
///               provisionDelegate:self];
///
/// \endcode\param fromController The calling UIViewController
///
/// \param primaryAccountSuffix The Funding PAN suffix to be displayed is defined within the <code>primaryAccountSuffix</code> key.  This value should be 4 digits and will have dots prepended to indicate that it is a suffix.
///
/// \param cardholderName The name of the person as shown on the card
///
/// \param scheme See <code>CardScheme</code>
///
/// \param encryptedPayload Card information encrypted in PKCS7
///
/// \param authorizationCode Authorization code
///
/// \param provisionDelegate See <code>TPCSDKProvisionDelegate</code>
///
+ (void)provisionFromController:(UIViewController * _Nonnull)controller primaryAccountSuffix:(NSString * _Nonnull)primaryAccountSuffix cardholderName:(NSString * _Nullable)cardholderName scheme:(enum CardScheme)scheme encryptedPayload:(NSString * _Nonnull)encryptedPayload authorizationCode:(NSString * _Nonnull)authorizationCode provisionDelegate:(id <TPCSDKProvisionDelegate> _Nullable)provisionDelegate;
/// Displays an interface that lets users add cards to Apple Pay from within your app.
/// You need to use the <code>getCardDigitizationResult</code> API to obtain a <code>CardDigitizationResult</code> object.
/// If either the <code>localPKPass</code> or <code>remotePKPass</code> properties of the <code>CardDigitizationResult</code> object are not nil,
/// then access the <code>primaryAccountIdentifier</code> property of the <a href="https://developer.apple.com/documentation/passkit/pksecureelementpass"><code>PKSecureElementPass</code></a> object.
/// Pass the retrieved <code>primaryAccountIdentifier</code> to the provision API.
/// \code
/// TPCSDK.provision(fromController: self,
///            primaryAccountSuffix: "1234",
///                  cardholderName: "John Doe",
///                    schemeString: "MASTERCARD",
///                encryptedPayload: "PKCS7 encrypted PAN",
///               authorizationCode: "code",
///                       productId: "productId",
///        primaryAccountIdentifier: "primaryAccountIdentifier",
///               provisionDelegate: self)
///
/// \endcode\code
/// [TPCSDK provisionFromController:self
///            primaryAccountSuffix:@"1234"
///                cardholderName:@"John Doe"
///                  schemeString:@"MASTERCARD"
///              encryptedPayload:@"PKCS7 encrypted PAN"
///             authorizationCode:@"code"
///                     productId:@"productId"
///      primaryAccountIdentifier:@"primaryAccountIdentifier"                     
///             provisionDelegate:self];
///
/// \endcode\param fromController The calling UIViewController
///
/// \param primaryAccountSuffix The Funding PAN suffix to be displayed is defined within the <code>primaryAccountSuffix</code> key.  This value should be 4 digits and will have dots prepended to indicate that it is a suffix.
///
/// \param cardholderName The name of the person as shown on the card
///
/// \param schemeString Card’s scheme. Could be <code>VISA</code>, <code>MASTERCARD</code>, <code>PAGOBANCOMAT</code> or others. NOTE: It has to be UPPERCASE string, <code>PAGOBANCOMAT</code> is only available in iOS 16 and above.
///
/// \param encryptedPayload Card information encrypted in PKCS7
///
/// \param authorizationCode Authorization code
///
/// \param productId Unique identifier of the card product. This data can be retrieved from Bank’s Card Management System. It is only applicable for domestic schemes. Maximum length is 32 characters.
///
/// \param primaryAccountIdentifier An FPANID for the card. If this parameter is not provided, the SDK will automatically retrieve it from local data, based on primaryAccountSuffix value.
///
/// \param provisionDelegate See <code>TPCSDKProvisionDelegate</code>
///
+ (void)provisionFromController:(UIViewController * _Nonnull)controller primaryAccountSuffix:(NSString * _Nonnull)primaryAccountSuffix cardholderName:(NSString * _Nullable)cardholderName schemeString:(NSString * _Nonnull)schemeString encryptedPayload:(NSString * _Nonnull)encryptedPayload authorizationCode:(NSString * _Nonnull)authorizationCode productId:(NSString * _Nullable)productId primaryAccountIdentifier:(NSString * _Nullable)primaryAccountIdentifier provisionDelegate:(id <TPCSDKProvisionDelegate> _Nullable)provisionDelegate;
/// Generate <code>PKAddPaymentPassRequest</code> for provisioning in Wallet Extension flow
/// (callback <a href="https://developer.apple.com/documentation/passkit/pkissuerprovisioningextensionhandler/3571365-generateaddpaymentpassrequestfor">generateAddPaymentPassRequestForPassEntryWithIdentifier</a>).
/// <ul>
///   <li>
///     Since 2.3.0
///   </li>
/// </ul>
/// \param input The input parameters required to generate <code>PKAddPaymentPassRequest</code>.
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns <code>PKAddPaymentPassRequest</code>. Otherwise, it returns error details.
/// Possible errors:
/// <ul>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.internalInconsistency</code>
///   </li>
///   <li>
///     <code>TPCError.deviceEnvironmentUnsafe</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
///
+ (void)generateAddPaymentPassRequestForInput:(GenerateAddPaymentPassRequestInput * _Nonnull)input completion:(void (^ _Nonnull)(PKAddPaymentPassRequest * _Nullable, NSError * _Nullable))completion;
/// warning:
/// This API is deprecated. Please use getToken API with serialNumber instead.
/// Get pending activation payment pass from local and remote device
/// note:
/// Using <code>FundingCard</code> object initialized with Card’s Scheme and Encrypted Payload
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.getPendingActivationPass(card: card) {
///    (pendingActivationPass, error) in
/// }
///
/// \endcode\code
/// [TPCSDK getPendingActivationPassWithCard:card
///                               completion:^(PendingActivationPass * _Nullable pendingActivationPass, NSError * _Nullable error) {
/// }];
///
/// \endcode\param card See <code>FundingCard</code>. Using <code>FundingCard</code> object initialized with Card’s Scheme and Encrypted Payload.
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns pendingActivationPass - See <code>PendingActivationPass</code>. Otherwise, it returns error details.
///
+ (void)getPendingActivationPassWithCard:(FundingCard * _Nonnull)card completion:(void (^ _Nonnull)(PendingActivationPass * _Nullable, NSError * _Nullable))completion SWIFT_DEPRECATED_MSG("This API is deprecated. Please use getToken API with serialNumber instead.");
/// Activate payment pass
/// note:
/// Use PKPass from <code>TPCSDK.getPendingActivationPass</code> and <code>FundingCard</code> object initialized with Card’s Scheme and Encrypted Payload. Authorization code and nonce must be provided.
/// <ul>
///   <li>
///     Possible errors: This method returns two possible types of errors: TPCError, which is returned from the SDK, and Error, which is returned directly from Apple’s PKPassLibrary.activate.
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
///   <li>
///     <code>Error</code> Returns directly from <code>PKPassLibrary.activate</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.activatePass(pass: localPass,
///                     card: card,
///        authorizationCode: authorizationCode,
///                    nonce: nonce) {
///    (success, error) in
/// }
///
/// \endcode\code
/// [TPCSDK activatePassWithPass:pass
///                         card:card
///            authorizationCode:code
///                        nonce:nonce
///                   completion:^(BOOL success, NSError * _Nullable error) {
/// }];
///
/// \endcode\param pass See <code>PassKit.PKPass</code>
///
/// \param card See <code>FundingCard</code>
///
/// \param authorizationCode Authorization code
///
/// \param nonce Nonce
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, the success value is<code>true</code>. Otherwise, it returns error details.
///
+ (void)activatePassWithPass:(PKPass * _Nonnull)pass card:(FundingCard * _Nonnull)card authorizationCode:(NSString * _Nonnull)authorizationCode nonce:(NSString * _Nullable)nonce completion:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completion;
/// Get Payment Passes from PKPassLibrary
+ (void)getPaymentPassesWithCompletion:(void (^ _Nonnull)(NSArray<PKPass *> * _Nullable, NSArray<PKPaymentPass *> * _Nullable))completion;
/// Get the list of tokens for the given card
/// note:
/// Each <code>Token</code> provides the method <code>Token.isOnCurrentDevice</code> to identify the tokens is on current device (only for Apple Pay).
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.getTokens(card: card) {
///    (tokenList, error) in
/// }
///
/// \endcode\code
/// [TPCSDK getTokensWithCard:card
///                completion:^(NSArray<Token *> * _Nullable tokenList, NSError * error) {
/// }];
///
/// \endcode\param card See <code>FundingCard</code>. Using <code>FundingCard</code> object initialized with Card’s Scheme and Encrypted Payload
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns Token list. Otherwise, it returns error details.
///
+ (void)getTokensWithCard:(FundingCard * _Nonnull)card completion:(void (^ _Nonnull)(NSArray<Token *> * _Nullable, NSError * _Nullable))completion;
/// Get asset for the given token requestor asset ID
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.getTokenRequestorAsset(assetId: tokenRequestorId) {
///    (tokenRequestorAsset, error) in
/// }
///
/// \endcode\code
/// [TPCSDK getTokenRequestorAssetWithAssetId:id
///                                completion:^(NSArray<TokenRequestorAsset *> * _Nullable tokenRequestorAsset, NSError * error) {
/// }];
///
/// \endcode\param assetId See <code>Token.TokenRequestor.id</code>
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns Token Requestor asset. Otherwise, it returns error details.
///
+ (void)getTokenRequestorAssetWithAssetId:(NSString * _Nonnull)assetId completion:(void (^ _Nonnull)(NSArray<TokenRequestorAsset *> * _Nullable, NSError * _Nullable))completion;
/// Update token state
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.updateTokenState(tokenId: tokenId,
///                tokenRequestorId: tokenRequestorId,
///                          scheme: scheme
///               authorizationCode: authorizationCode,
///                          action: .Suspend) {
///     (success, error) in
/// }
///
/// \endcode\code
/// [TPCSDK updateTokenStateWithTokenId:tokenId
///                    tokenRequestorId:tokenRequestorId
///                              scheme:scheme
///                   authorizationCode:code
///                              action:state
///                          completion:^(BOOL success, NSError * error) {
/// }];
///
/// \endcode\param tokenId See <code>Token.id</code>
///
/// \param tokenRequestorId Unique identifier of the token requestor allocated by the TSP Scheme. It shall be provided for VISA scheme.
///
/// \param scheme See <code>CardScheme</code>
///
/// \param authorizationCode Authorization code provided by issuer.
///
/// \param action See <code>TokenState</code>
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, the success value is<code>true</code>. Otherwise, it returns error details and the success value is<code>false</code>.
///
+ (void)updateTokenStateWithTokenId:(NSString * _Nonnull)tokenId tokenRequestorId:(NSString * _Nonnull)tokenRequestorId scheme:(enum CardScheme)scheme authorizationCode:(NSString * _Nonnull)authorizationCode action:(enum TokenState)action completion:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completion;
/// Update token state
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.updateTokenState(tokenId: tokenId,
///                tokenRequestorId: tokenRequestorId,
///                    schemeString: scheme
///               authorizationCode: authorizationCode,
///                          action: .Suspend) {
///    (success, error) in
/// }
///
/// \endcode\code
/// [TPCSDK updateTokenStateWithTokenId:tokenId
///                    tokenRequestorId:tokenRequestorId
///                        schemeString:scheme
///                   authorizationCode:code
///                              action:state
///                          completion:^(BOOL success, error) {
/// }];
///
/// \endcode\param tokenId See <code>Token.id</code>
///
/// \param tokenRequestorId Unique identifier of the token requestor allocated by the TSP Scheme. It shall be provided for VISA scheme.
///
/// \param schemeString Card’s scheme. Could be <code>VISA</code>, <code>MASTERCARD</code>, <code>PAGOBANCOMAT</code> or others, <code>PAGOBANCOMAT</code> is only available in iOS 16 and above.
///
/// \param authorizationCode Authorization code provided by issuer.
///
/// \param action See <code>TokenState</code>
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, the success value is<code>true</code>. Otherwise, it returns error details and the success value is<code>false</code>.
///
+ (void)updateTokenStateWithTokenId:(NSString * _Nonnull)tokenId tokenRequestorId:(NSString * _Nonnull)tokenRequestorId schemeString:(NSString * _Nonnull)schemeString authorizationCode:(NSString * _Nonnull)authorizationCode action:(enum TokenState)action completion:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completion;
/// Get cards
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.getCards(userId: userId,
///      authorizationCode: authorizationCode,
///                    kyc: kyc) {
///    (cards, error) in
/// }
///
/// \endcode\code
/// [TPCSDK getCardsWithUserId:userId
///          authorizationCode:code
///                        kyc:kyc
///                 completion:^(NSArray<CardList *> * _Nullable cardList, NSError * _Nullable error) {
/// }];
///
/// \endcode\param userId User ID
///
/// \param authorizationCode Authorization code
///
/// \param kyc KYC
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns the card list - See <code>CardList</code>. Otherwise, it returns error details.
///
+ (void)getCardsWithUserId:(NSString * _Nonnull)userId authorizationCode:(NSString * _Nonnull)authorizationCode kyc:(NSString * _Nonnull)kyc completion:(void (^ _Nonnull)(NSArray<CardList *> * _Nullable, NSError * _Nullable))completion;
/// Get asset for the given card
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.getCardAsset(cardId: cardId,
///                        kyc: kyc,
///                       size: .S) {
///    (cardAsset, error) in
/// }
///
/// \endcode\code
/// [TPCSDK getCardAssetWithCardId:cardId
///                            kyc:kyc
///                           size:size
///                     completion:^(CardAsset * _Nullable cardAsset, NSError * _Nullable error) {
/// }];
///
/// \endcode\param cardId Card ID
///
/// \param kyc KYC
///
/// \param size See <code>CardAssetSize</code>
///
/// \param cardAsset See <code>CardAsset</code>
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns the card asset - See <code>CardAsset</code>. Otherwise, it returns error details.
///
+ (void)getCardAssetWithCardId:(NSString * _Nonnull)cardId kyc:(NSString * _Nonnull)kyc size:(enum CardAssetSize)size completion:(void (^ _Nonnull)(CardAsset * _Nullable, NSError * _Nullable))completion;
/// Request encrypted payload for a given funding card
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.getPayload(authorizationCode: code,
///                              cardId: cardId,
///                                 kyc: kyc) {
///    (payload, error) in
/// }
///
/// \endcode\code
/// [TPCSDK getPayloadWithAuthorizationCode:code
///                                  cardId:cardId
///                                     kyc:kyc
///                              completion:^(NSString * _Nullable encryptedPayload, NSError * _Nullable error) {
/// }];
///
/// \endcode\param authorizationCode Authorization code
///
/// \param cardId Card ID
///
/// \param kyc KYC
///
/// \param payload Card information encrypted in PKCS7
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns the payload - the Card information encrypted in PKCS7. Otherwise, it returns error details.
///
+ (void)getPayloadWithAuthorizationCode:(NSString * _Nonnull)authorizationCode cardId:(NSString * _Nonnull)cardId kyc:(NSString * _Nonnull)kyc completion:(void (^ _Nonnull)(NSString * _Nullable, NSError * _Nullable))completion;
/// Request encrypted payload for a given funding card
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.getEligibleTokenRequestor(card: card,
///                   publicKeyIdentifier: publicKeyId) {
///    (TokenRequestorList, error) in
/// }
///
/// \endcode\code
/// [TPCSDK getEligibleTokenRequestorWithCard:card
///                       publicKeyIdentifier:publicKeyId
///                                completion:^(NSArray<TokenRequestor *> * _Nullable tokenRequestorList, NSError * _Nullable error) {
/// }];
///
/// \endcode\param card <code>FundingCard</code> object initialized with Card’s Scheme and Encrypted Payload
///
/// \param publicKeyIdentifier Identifier of the key used to encrypt payload
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns the list of tokenRequestors - See <code>TokenRequestor</code>. Otherwise, it returns error details.
///
+ (void)getEligibleTokenRequestorWithCard:(FundingCard * _Nonnull)card publicKeyIdentifier:(NSString * _Nullable)publicKeyIdentifier completion:(void (^ _Nonnull)(NSArray<TokenRequestor *> * _Nullable, NSError * _Nullable))completion;
/// Initiate push provision to scheme
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.schemePushProvision(card: card,
///             publicKeyIdentifier: publicKeyId,
///               authorizationCode: code,
///      termsAndConditionsAccepted: true,
///                     callbackUrl: callbackUrl,
///                    callbackType: callbackType,
///                     pushHandler: pushHandler) {
///     (pushUrl, error) in
/// }
///
/// \endcode\code
/// [TPCSDK schemePushProvisionWithCard:card
///                 publicKeyIdentifier:publicKeyId
///                   authorizationCode:code
///          termsAndConditionsAccepted:TRUE
///                         callbackUrl:callbackUrl
///                        callbackType:callbackType
///                         pushHandler:pushHandler
///                          completion:^(NSString * _Nullable pushUrl, NSError * _Nullable error) {
/// }];
///
/// \endcode\param card <code>FundingCard</code> object initialized with Card’s Scheme and Encrypted Payload
///
/// \param publicKeyIdentifier Identifier of the key used to encrypt payload
///
/// \param authorizationCode Authorization code
///
/// \param termsAndConditionsAccepted Terms and conditions accepted by user
///
/// \param callbackUrl URL used by the token requestor to pass control back to issuer application
///
/// \param callbackType ANDROID, IOS, or WEB
///
/// \param pushHandler Token requestor push handler
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns the pushUrl - a token requestor URL used for redirection. Otherwise, it returns error details.
///
+ (void)schemePushProvisionWithCard:(FundingCard * _Nonnull)card publicKeyIdentifier:(NSString * _Nullable)publicKeyIdentifier authorizationCode:(NSString * _Nonnull)authorizationCode termsAndConditionsAccepted:(BOOL)termsAndConditionsAccepted callbackUrl:(NSString * _Nonnull)callbackUrl callbackType:(NSString * _Nonnull)callbackType pushHandler:(NSString * _Nonnull)pushHandler completion:(void (^ _Nonnull)(NSString * _Nullable, NSError * _Nullable))completion;
/// This Api helps to add Mastercard to click to pay token requestor
/// <ul>
///   <li>
///     Possible errors:
///   </li>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.deviceEnvironmentUnsafe</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
/// </ul>
/// \code
/// TPCSDK.addCardToClick2PayMC(userDetails: userDetails,
///                        encryptedPayload: encryptedPayload,
///                       authorizationCode: code,
///                     publicKeyIdentifier: publicKeyId,
///                              privacyURL: privacyURL,
///                                  tncURL: tncURL) {
///     (error) in
/// }
///
/// \endcodesince:
/// 2.4.0
/// \param userDetails <code>Click2PayUserDetails</code> object initialized with user inputs for first name, last name, locale, phone number, country code and email.
///
/// \param encryptedPayload This parameter is the hexadecimal string representation of an encrypted payload for MasterCard click to pay, including fpan and exp.
///
/// \param authorizationCode Authorization code provided by issuer
///
/// \param publicKeyIdentifier Identifier of the key used to encrypt payload
///
/// \param privacyURL URL container for Consumer’s privacy consent status
///
/// \param tncURL URL container for Consumer’s Terms and Conditions consent status
///
/// \param completion The callback invoked when the operation is completed. When it succeeds, it returns nil for error. Otherwise, it returns error details.
///
+ (void)addCardToClick2PayMCWithUserDetails:(Click2PayUserDetails * _Nonnull)userDetails encryptedPayload:(NSString * _Nonnull)encryptedPayload authorizationCode:(NSString * _Nonnull)authorizationCode publicKeyIdentifier:(NSString * _Nonnull)publicKeyIdentifier privacyURL:(NSString * _Nonnull)privacyURL tncURL:(NSString * _Nonnull)tncURL completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Methods that let the system inform you when a push provisioning request has succeeded or failed.
SWIFT_PROTOCOL("_TtP11TPCSDKSwift23TPCSDKProvisionDelegate_")
@protocol TPCSDKProvisionDelegate <NSObject>
/// Callback when provision process from PassKit is complete
/// <ul>
///   <li>
///     <code>TPCError.notConfigured</code>
///   </li>
///   <li>
///     <code>TPCError.invalidArgument</code>
///   </li>
///   <li>
///     <code>TPCError.invalidFormat</code>
///   </li>
///   <li>
///     <code>TPCError.serverError</code>
///   </li>
///   <li>
///     <code>Error</code> Returns directly from Apple Pay API. Please check the details here https://developer.apple.com/documentation/passkit/pkaddpaymentpassviewcontrollerdelegate/1615942-addpaymentpassviewcontroller
///   </li>
/// </ul>
/// \code
/// func onProvisionCompletion(pass: PKPaymentPass?, error: Error?) {
///  if let error = error {
///      if let tpcError = error as? TPCError {
///          // handle TPCError
///      } else {
///          // handle Apple Pay Error
///      }
///  } else if let pass = pass {
///      // handle successful result with pass object
///  }
/// }
///
/// \endcode\param pass Payment pass created on device, nil if operation failed
///
/// \param error This method returns two possible types of errors: TPCError, which is returned from the SDK, and Error, which is returned directly from ApplePay API.
///
- (void)onProvisionCompletionWithPass:(PKPaymentPass * _Nullable)pass error:(NSError * _Nullable)error;
@end


/// Token for the payment card
SWIFT_CLASS("_TtC11TPCSDKSwift5Token")
@interface Token : NSObject
/// Token ID
@property (nonatomic, copy) NSString * _Nullable id;
/// Token state
/// Possible values: ACTIVE, SUSPENDED, DELETED, PENDING_IDV
@property (nonatomic, copy) NSString * _Nullable state;
/// Token suffix
@property (nonatomic, copy) NSString * _Nullable suffix;
/// Token expiry date
@property (nonatomic, copy) NSString * _Nullable expiryDate;
/// Device
@property (nonatomic, strong) Device * _Nullable device;
/// Token Requestor object, which only contains identifier & name (MasterCard only).
@property (nonatomic, strong) TokenRequestor * _Nullable tokenRequestor;
/// Is token on current device.
@property (nonatomic) BOOL isOnCurrentDevice;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Token Requestor
SWIFT_CLASS("_TtC11TPCSDKSwift14TokenRequestor")
@interface TokenRequestor : NSObject
/// Token requestor ID
@property (nonatomic, copy) NSString * _Nullable id;
/// Token requestor name
@property (nonatomic, copy) NSString * _Nullable name;
/// Token requestor logo URL
@property (nonatomic, copy) NSString * _Nullable logoURL;
/// Token requestor logo ID
@property (nonatomic, copy) NSString * _Nullable logoId;
/// Push methods supported by token requestor
@property (nonatomic, copy) NSArray<PushMethod *> * _Nullable pushMethods;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Token requestor asset
SWIFT_CLASS("_TtC11TPCSDKSwift19TokenRequestorAsset")
@interface TokenRequestorAsset : NSObject
/// Type of asset
/// Possible values: application/pdf, image/svg+xml and image/png
@property (nonatomic, copy) NSString * _Nullable type;
/// Base64 encoded data
@property (nonatomic, copy) NSString * _Nullable data;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Token State
typedef SWIFT_ENUM(NSInteger, TokenState, open) {
/// Activate
  TokenStateActivate = 0,
/// Suspend
  TokenStateSuspend = 1,
/// Resume
  TokenStateResume = 2,
/// Delete
  TokenStateDelete = 3,
};

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
